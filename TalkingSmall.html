<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for Linux (vers 14 June 2007), see www.w3.org">
<title>Final Draft - Talking Small</title>
<meta content="text/html; charset=us-ascii" http-equiv=
"content-type">
<style type="text/css">
@import url('https://themes.googleusercontent.com/fonts/css?kit=0h_paUF1zYrDw0BiVvmPIPyDN7cgeRfA_woaXUgMUYU');.lst-kix_fgel5qqd5eop-0>li:before{content:"\0025cf  "}.lst-kix_fgel5qqd5eop-2>li:before{content:"\0025a0  "}.lst-kix_gqlj9k2x9hd1-0>li:before{content:"\0025cf  "}.lst-kix_lkvhkm3b5a51-7>li:before{content:"\0025cb  "}.lst-kix_fgel5qqd5eop-7>li:before{content:"\0025cb  "}.lst-kix_lkvhkm3b5a51-2>li:before{content:"\0025a0  "}.lst-kix_gqlj9k2x9hd1-6>li:before{content:"\0025cf  "}.lst-kix_lkvhkm3b5a51-1>li:before{content:"\0025cb  "}.lst-kix_lkvhkm3b5a51-5>li:before{content:"\0025a0  "}.lst-kix_lkvhkm3b5a51-3>li:before{content:"\0025cf  "}.lst-kix_gqlj9k2x9hd1-2>li:before{content:"\0025a0  "}.lst-kix_gqlj9k2x9hd1-1>li:before{content:"\0025cb  "}.lst-kix_fgel5qqd5eop-8>li:before{content:"\0025a0  "}ul.lst-kix_gqlj9k2x9hd1-7{list-style-type:none}ul.lst-kix_gqlj9k2x9hd1-8{list-style-type:none}.lst-kix_fgel5qqd5eop-3>li:before{content:"\0025cf  "}ul.lst-kix_gqlj9k2x9hd1-5{list-style-type:none}ul.lst-kix_gqlj9k2x9hd1-6{list-style-type:none}ul.lst-kix_fgel5qqd5eop-3{list-style-type:none}ul.lst-kix_fgel5qqd5eop-4{list-style-type:none}.lst-kix_gqlj9k2x9hd1-3>li:before{content:"\0025cf  "}ul.lst-kix_fgel5qqd5eop-1{list-style-type:none}ul.lst-kix_fgel5qqd5eop-2{list-style-type:none}.lst-kix_lkvhkm3b5a51-4>li:before{content:"\0025cb  "}ul.lst-kix_fgel5qqd5eop-7{list-style-type:none}ul.lst-kix_fgel5qqd5eop-8{list-style-type:none}.lst-kix_lkvhkm3b5a51-6>li:before{content:"\0025cf  "}ul.lst-kix_fgel5qqd5eop-5{list-style-type:none}.lst-kix_gqlj9k2x9hd1-7>li:before{content:"\0025cb  "}ul.lst-kix_fgel5qqd5eop-6{list-style-type:none}ul.lst-kix_fgel5qqd5eop-0{list-style-type:none}.lst-kix_fgel5qqd5eop-4>li:before{content:"\0025cb  "}.lst-kix_fgel5qqd5eop-5>li:before{content:"\0025a0  "}.lst-kix_gqlj9k2x9hd1-8>li:before{content:"\0025a0  "}ul.lst-kix_gqlj9k2x9hd1-0{list-style-type:none}ul.lst-kix_gqlj9k2x9hd1-3{list-style-type:none}ul.lst-kix_gqlj9k2x9hd1-4{list-style-type:none}.lst-kix_lkvhkm3b5a51-0>li:before{content:"  "}ul.lst-kix_gqlj9k2x9hd1-1{list-style-type:none}ul.lst-kix_gqlj9k2x9hd1-2{list-style-type:none}.lst-kix_fgel5qqd5eop-1>li:before{content:"\0025cb  "}ul.lst-kix_lkvhkm3b5a51-1{list-style-type:none}.lst-kix_gqlj9k2x9hd1-5>li:before{content:"\0025a0  "}ul.lst-kix_lkvhkm3b5a51-2{list-style-type:none}.lst-kix_fgel5qqd5eop-6>li:before{content:"\0025cf  "}ul.lst-kix_lkvhkm3b5a51-0{list-style-type:none}ul.lst-kix_lkvhkm3b5a51-5{list-style-type:none}ul.lst-kix_lkvhkm3b5a51-6{list-style-type:none}ul.lst-kix_lkvhkm3b5a51-3{list-style-type:none}ul.lst-kix_lkvhkm3b5a51-4{list-style-type:none}.lst-kix_lkvhkm3b5a51-8>li:before{content:"\0025a0  "}ul.lst-kix_lkvhkm3b5a51-8{list-style-type:none}.lst-kix_gqlj9k2x9hd1-4>li:before{content:"\0025cb  "}ul.lst-kix_lkvhkm3b5a51-7{list-style-type:none}ol{margin:0;padding:0}.c7{vertical-align:baseline;color:#000000;font-size:11pt;font-style:normal;font-family:"Arial";text-decoration:none;font-weight:normal}.c2{line-height:1.0;padding-top:0pt;text-align:left;direction:ltr;padding-bottom:0pt}.c17{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c0{font-size:10pt;font-family:"Consolas"}.c10{color:#1155cc;text-decoration:underline}.c12{margin:5px;border:1px solid black}.c8{font-size:10pt;font-family:"Courier New"}.c16{text-indent:36pt;margin-left:180pt}.c3{direction:ltr;margin-left:36pt}.c1{color:inherit;text-decoration:inherit}.c19{margin:0;padding:0}.c9{font-style:italic}.c15{line-height:1.35}.c20{font-family:"Courier New"}.c13{font-family:"Consolas"}.c18{color:#93a1a1}.c11{font-weight:bold}.c6{height:11pt}.c14{padding-top:10pt}.c4{direction:ltr}.c5{padding-left:0pt}.title{padding-top:0pt;line-height:1.15;text-align:left;color:#000000;font-size:21pt;font-family:"Trebuchet MS";padding-bottom:0pt}.subtitle{padding-top:0pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:13pt;font-family:"Trebuchet MS";padding-bottom:10pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:16pt;font-family:"Trebuchet MS";padding-bottom:0pt}h2{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:13pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt}h3{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt}h4{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-size:11pt;text-decoration:underline;font-family:"Trebuchet MS";padding-bottom:0pt}h5{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt}h6{padding-top:8pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt}
</style>
</head>
<body class="c17">
<p class="c4 title"><a name="h.msddflkn6czr" id=
"h.msddflkn6czr"></a><span>Talking Small</span></p>
<p class="c4 subtitle"><a name="h.rop6l4owzvp1" id=
"h.rop6l4owzvp1"></a><span>Using Eclipse Paho's MQTT on</span>
<span>BeagleBone</span><span>&nbsp;Black and Raspberry
Pi</span></p>
<author>D.J. Walker Morgan</author>
<p class="c6 c4"></p>
<p class="c4"><span class="c9">How would you connect the
information from a temperature sensor on a BeagleBone Black to an
LED display on a Raspberry Pi and would your solution scale up to
many sensors and displays? In this article we&rsquo;ll show how
MQTT and the Eclipse Paho project can let you answer that
challenge.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>The arrival of the Raspberry Pi and the
BeagleBone Black has heralded a time when a small Linux-powered
board can easily, and economically, make sense as a complex sensor
or display in the Internet of Things. It also means that developers
can end up using web technology that's not suited to the Internet
of Things, where the connections may only be occasionally available
and as reliable as a cellphone call and where devices need to sip
power while sending and receiving information.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>This is where MQTT comes in to take on these
connectivity problems and open up a whole realm of possibilities
for developers to create smarter, more connected applications. MQTT
is a system, and a network protocol, for broadcasting and listening
for information over networks. Designed as a complement to
enterprise messaging systems, MQTT is a lightweight publish and
subscribe protocol. The idea with what was called at the time,=
Message Queuing Telemetry Transport, to fill the gap
between</span><span>&nbsp;the</span> <span>numerous devices and
applications</span> <span>that</span><span>&nbsp;could produce data
and the wider world of data consumers. A</span><span>s these
devices were typically outside of the corporate network the
protocol</span> <span>needed to be resilient to network issues.
Now, known just as MQTT (with no acronym), the most recent version,
MQTT 3.1, is being used as OASIS&rsquo;s standard for</span>
<span>messaging</span> <span>for the internet of things, further
extending MQTT&rsquo;s industry support and alongside that work,
the Eclipse Foundation&rsquo;s M2M project is curating open source
versions of components for MQTT-based systems.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>In practice, MQTT lets developers write
applications which publish their data as messages to the MQTT
network without worrying themselves with how other applications
will receive that data. The messages are published to topics,
strings which can resemble filesystem paths, like
&ldquo;/rooms/a1/environment/temperature&rdquo; or
&ldquo;/raspberrypi/status&rdquo; or
&ldquo;/beaglebone/running/process&rdquo;. This message data
&ndash; the payload &ndash; is most typically small packets, but
MQTT is flexible enough to allow it to be as much as 256MB. The
MQTT overhead itself is as little as two bytes over the payload and
topic and the load on clients is small as the broker takes over the
heavier lifting of redistributing messages.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>Other developers can write applications that
select which topics, or wildcard-based ranges of topics they will
then receive messages for. These are the subscribers. There&rsquo;s
nothing to stop a client being both a publisher and a subscriber
though. Bringing the two sides together and providing the glue of
an MQTT network are the MQTT brokers. These are applications built
to route, or retain, messages between publishing and subscribing
clients.</span></p>
<h2 class="c4"><a name="h.eemk8ff15vwk" id=
"h.eemk8ff15vwk"></a><span>Getting building - a publishing
sensor</span></h2>
<p class="c6 c4"></p>
<p class="c4"><span>These concepts are best demonstrated so
let&rsquo;s start building our temperature sensor. We&rsquo;re
doing this on the BeagleBone Black. It&rsquo;s a pretty
self-contained device so you just need to add power and network and
ssh to &ldquo;root@beaglebone.local&rdquo; to log into one fresh
out of the box. You can, of course, attach a monitor and use a GUI
on the BeagleBone Black - or the Raspberry Pi, which we will come
to later - but here we are keeping hardware and software tooling
requirements to a minimum so we can focus on MQTT.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>To attach a temperature sensor to a BeagleBone
Black, we have followed the</span> <span class="c10"><a class="c1"
href=
"http://learn.adafruit.com/measuring-temperature-with-a-beaglebone-black/overview">
tutorial</a></span><span>&nbsp;(</span><span class="c10"><a class=
"c1" href=
"http://learn.adafruit.com/measuring-temperature-with-a-beaglebone-black/overview">http://learn.adafruit.com/measuring-temperature-with-a-beaglebone-black/overview</a></span><span>)
created by Simon Monk for the AdaFruit Learning System. The
electronics are very simple and connect the three pins of a TMP36
temperature sensor to an analogue input on the BeagleBone Black.
The software side involves</span> <span class="c10"><a class="c1"
href=
"http://learn.adafruit.com/setting-up-io-python-library-on-beaglebone-black/installation">
installing</a></span><span>&nbsp;(</span><span class=
"c10"><a class="c1" href=
"http://learn.adafruit.com/setting-up-io-python-library-on-beaglebone-black/installation">http://learn.adafruit.com/setting-up-io-python-library-on-beaglebone-black/installation</a></span><span>)
and using an AdaFruit library to read the value and we end up
running a Python program similar to this:</span></p>
<p class="c6 c4"></p>
<ul class="c19 lst-kix_lkvhkm3b5a51-0 start">
<li class="c3 c5"><span class="c0">import Adafruit_BBIO.ADC as
ADC</span></li>
<li class="c3 c5"><span class="c0">import time</span></li>
<li class="c3 c5"><span class="c0">&nbsp;</span></li>
<li class="c3 c5"><span class="c0">sensor_pin = 'P9_40'</span></li>
<li class="c3 c5"><span class="c0">&nbsp;</span></li>
<li class="c3 c5"><span class="c0">ADC.setup()</span></li>
<li class="c3 c5"><span class="c0">&nbsp;</span></li>
<li class="c3 c5"><span class="c0">while True:</span></li>
<li class="c3 c5"><span class="c0">&nbsp; &nbsp;reading =
ADC.read(sensor_pin)</span></li>
<li class="c3 c5"><span class="c0">&nbsp; &nbsp;millivolts =
reading * 1800 &nbsp;# 1.8V reference = 1800 mV</span></li>
<li class="c3 c5"><span class="c0">&nbsp; &nbsp;temp_c =
(millivolts - 500) / 10</span></li>
<li class="c3 c5"><span class="c0">&nbsp; &nbsp;print('mv=%.2f
C=%.2f' % (millivolts, temp_c)</span></li>
<li class="c3 c5"><span class="c0">&nbsp;
&nbsp;time.sleep(1)</span></li>
</ul>
<p class="c6 c4"></p>
<p class="c4"><span>So now we have a source of temperature data.
Now we can MQTT enable this program. Our first stop is the Eclipse
Paho project where MQTT client libraries for various languages have
been assembled. There you can find the Paho Python library, but as
it is yet to be formally packaged and released, we will need to
build it. To build it for the BeagleBone Black&rsquo;s Angstrom
Linux distribution we first need to download the source code using
git:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">git clone
git://git.</span><span class=
"c0">eclipse.org/gitroot/paho/org.eclipse.paho.mqtt.python.git</span></p>
<p class="c3 c6"></p>
<p class="c4"><span>This will create a copy of the repository in
the directory &ldquo;org.eclipse.paho.mqtt.python&rdquo;. If we now
move into that directory we can get on with building the
code:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">cd
org.eclipse.paho.mqtt.python</span></p>
<p class="c3"><span class="c0">make</span></p>
<p class="c3"><span class="c0">make install</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>With the Paho MQTT library built, we can return
to our Python code and start adding the basic elements. The first
thing to do is to import the library:</span></p>
<p class="c6 c4"></p>
<ul class="c19 lst-kix_lkvhkm3b5a51-0">
<li class="c3 c15 c5"><span class="c0">import</span><span class=
"c0">&nbsp;</span><span class="c0">Adafruit_BBIO</span><span class=
"c0">.</span><span class="c0">ADC</span> <span class=
"c0">as</span><span class="c0">&nbsp;ADC</span></li>
<li class="c3 c5 c15"><span class="c0">import</span><span class=
"c0">&nbsp;time</span></li>
<li class="c3 c15 c5"><span class="c0">import paho.mqtt.client as
mqtt</span></li>
</ul>
<p class="c6 c4"></p>
<p class="c4"><span>Now we can set up the client connection to the
broker:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">mqttc = mqtt.Client()</span></p>
<p class="c3"><span class="c0">mqttc.connect("m2m.eclipse.org",
1883, 60)</span></p>
<p class="c3"><span class="c0">mqttc.loop_start()</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>Here we create our client and tell it to
connect to</span> <span class="c20">m2m.eclipse.org</span><span>.
That&rsquo;s the Eclipse public sandbox for M2M developers which
has been created to let people experiment with M2M without setting
up their own broker. That said, you can easily set up a broker
with</span> <span class="c10"><a class="c1" href=
"http://mosquitto.org">Mosquitto</a></span><span>&nbsp;(</span><span class="c10"><a class="c1"
href=
"http://mosquitto.org/">http://mosquitto.org/</a></span><span>)</span><span>,
the open source dedicated MQTT broker, if you wish. Other brokers
are available, but it&rsquo;s worth noting that Mosquitto is also
becoming an Eclipse M2M project.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>The connection to the broker is made over port
1883 and the connection will be kept alive with a 60 second ping in
the absence of any other activity. The code also starts up a thread
to handle incoming messages from the broker with the</span>
<span class="c9">loop_start</span><span>&nbsp;method. We are</span>
<span>now almost ready</span><span>&nbsp;to send messages to the
broker, but before we do that, we need come up with a topic. We
shall start with a root name of &ldquo;bbbexample&rdquo; for our
topics, then have a subtopic &ldquo;tmp36&rdquo; to represent the
temperature sensor and two sub-subtopics &ldquo;mv&rdquo; and
&ldquo;c&rdquo; to represent the milli-volt and centigrade readings
from that sensor. This will give us two absolute topics
&ldquo;bbbexample/tmp36/mv&rdquo; and
&ldquo;bbbexample/tmp36/c&rdquo;. Remember though, that if you are
working in a shared sandbox like m2m.eclipse.org, you will want to
change &ldquo;bbbexample&rdquo; to something</span> <span>unique to
you</span><span>&nbsp;(and the broker) or risk having your readings
overwritten by another person.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>With topics selected, once we&rsquo;ve printed
the millivolt and centigrade temperature readings we can
add:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">&nbsp;
mqttc.publish("bbbexample/tmp36/mv","%.2f" %
millivolts);</span></p>
<p class="c3"><span class="c0">&nbsp;
mqttc.publish("bbbexample/tmp36/c","%.2f" % temp_c);</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>Formatting the values to two decimal places for
tidiness. This gives us our complete program:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">import time</span></p>
<p class="c3"><span class="c0">import Adafruit_BBIO.ADC as
ADC</span></p>
<p class="c3"><span class="c0">import paho.mqtt.client as
mqtt</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">sensor_pin = 'P9_40'</span></p>
<p class="c3"><span class="c0">ADC.setup()</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">mqttc = mqtt.Client()</span></p>
<p class="c3"><span class="c0">mqttc.connect("m2m.eclipse.org",
1883, 60)</span></p>
<p class="c3"><span class="c0">mqttc.loop_start()</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">while True:</span></p>
<p class="c3"><span class="c0">&nbsp; reading =
ADC.read(sensor_pin)</span></p>
<p class="c3"><span class="c0">&nbsp; millivolts = reading * 1800
&nbsp;# 1.8V reference = 1800 mV</span></p>
<p class="c3"><span class="c0">&nbsp; temp_c = (millivolts - 500) /
10</span></p>
<p class="c3"><span class="c0">&nbsp; print('mv=%.2f C=%.2f' %
(millivolts, temp_c))</span></p>
<p class="c3"><span class="c0">&nbsp;
mqttc.publish("bbbexample/tmp36/mv","%.2f" %
millivolts);</span></p>
<p class="c3"><span class="c0">&nbsp;
mqttc.publish("bbbexample/tmp36/c","%.2f" % temp_c);</span></p>
<p class="c3"><span class="c0">&nbsp;
time.sleep(1)</span><sup><a href="#cmnt1" name="cmnt_ref1" id=
"cmnt_ref1">[a]</a></sup></p>
<p class="c4"><span>&nbsp;</span></p>
<p class="c4"><span>And running that should publish values to the
Eclipse sandbox every second. To check this is happening without
writing a client, we can make use of one feature of the Eclipse M2M
sandbox, the</span> <span class="c10"><a class="c1" href=
"http://eclipse.mqttbridge.com">Eclipse MQTT
Bridge</a></span><span>&nbsp;(http://eclipse.mqttbridge.com),</span><span>&nbsp;which
presents the contents of a sandbox in easily consumable web
formats. By using the curl utility, it is possible to obtain the
value from the last message passed through the broker like</span>
<span>so:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c8">#</span><span class=
"c8">&nbsp;</span><span class="c8 c11">curl
http://eclipse.mqttbridge.com/bbbexample/tmp36/c</span></p>
<p class="c3"><span class="c8">19.10</span><span class=
"c8">#</span></p>
<p class="c3 c6"></p>
<p class="c4"><span>We shall return to the BeagleBone Black and the
Python client later; the next stop for us is creating a client that
will use that temperature data.</span></p>
<p class="c6 c4"></p>
<h2 class="c4"><a name="h.rnvmbpo3hq1u" id=
"h.rnvmbpo3hq1u"></a><span>The listening Pi</span></h2>
<p class="c6 c4"></p>
<p class="c4"><span>Moving on to the Raspberry Pi, we are going to
use Java rather than Python, but the language and libraries used
are generally interchangeable between the platforms. The various
MQTT APIs typically use callbacks to notify applications when an
event has occurred. When we subscribe to messages from a topic and
a message subsequently arrives, an appropriate callback is invoked.
In Java the MQTT callbacks are encapsulated in an interface
called</span> <span class="c9">MqttCallback</span><span>. In our
code, we&rsquo;ll need to implement that interface:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">import
org.eclipse.paho.client.mqttv3.*;</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">public class PahoMqttSubscribe
implements MqttCallback</span></p>
<p class="c3"><span class="c0">{</span></p>
<p class="c3"><span class="c0">&nbsp; MqttClient client;</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">&nbsp; public PahoMqttSubscribe()
{}</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">&nbsp; public static void main
(String[] args) {</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; new
PahoMqttSubscribe().doDemo();</span></p>
<p class="c3"><span class="c0">&nbsp; }</span></p>
<p class="c3 c6"></p>
<p class="c6 c4"></p>
<p class="c4"><span>We&rsquo;ve also declared an</span>
<span class="c9">MqttClient</span><span>&nbsp;variable, an empty
constructor and a main method for our</span> <span class=
"c9">PahoMqttSubscribe</span><span>&nbsp;class. The</span>
<span class="c9">doDemo</span><span>&nbsp;method will contain most
of the code. In that method we need to create a connection to the
Eclipse sandbox.</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">public void doDemo() {</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; try {</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp; client = new
MqttClient("tcp://m2m.eclipse.org:1883",</span></p>
<p class="c16 c4"><span class=
"c0">MqttClient.generateClientId());</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp;
client.connect();</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>Like the Python code previously, this makes the
connection to m2m.eclipse.org though, unlike the Python, it takes a
URI which specifies protocol and port. It also explicitly generates
and sets a client ID for the program. Client applications
connecting to the broker need to have a unique client ID on that
broker. Where the client doesn&rsquo;t want to make use of the
reliable persistent features of MQTT, a function like</span>
<span class="c9">Mqtt.generateClientId()</span><span>&nbsp;can make
up an id based on the username, time and other local elements. Our
code then explicitly connects to the broker. Next, it needs to
configure the client so it receives those callbacks we previously
mentioned:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp;
client.setCallback(this);</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>The program is now ready to subscribe to a
topic. In the Python code, we were publishing the centigrade
temperature to bbbexample/tmp36/c, so let&rsquo;s subscribe to
that:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp;
client.subscribe("bbbexample/tmp36/c");</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>And we can continue doing whatever processing
we want after&hellip; in the example, we&rsquo;ll just idly wait
calling Thread.sleep. There&rsquo;s only one thing missing - we
haven&rsquo;t implemented the methods needed by MqttCallback, and
most importantly, the messageArrived callback. This delivers the
topic the message has been sent to and the message itself. For now,
the code can just print the topic and the message
payload:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">&nbsp;public void
messageArrived(String topic, MqttMessage message)</span></p>
<p class="c16 c4"><span class="c0">throws Exception</span></p>
<p class="c3"><span class="c0">&nbsp; {</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; System.out.println
(topic + " " + new String(message.getPayload()));</span></p>
<p class="c3"><span class="c0">&nbsp; }</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>These aren&rsquo;t the only callbacks needed
though, so the code will need</span>
<span>to</span><span>&nbsp;declare the others, even if they only do
nothing:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">&nbsp; public void connectionLost
(Throwable cause) {}</span></p>
<p class="c3"><span class="c0">&nbsp; public void
deliveryComplete(IMqttDeliveryToken token) {}</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>The</span> <span class=
"c9">connectionLost</span><span>&nbsp;callback allows an
application to manage reconnection to the broker, while the</span>
<span class="c9">deliveryComplete</span><span>&nbsp;callback is
called when a message is delivered to the broker. There are
actually two APIs available in Java for MQTT. One is a fully
non-blocking API which uses a number of token mechanisms to track
all progress. The other is the API we are using here which is a
wrapper around the non-blocking API and generally blocks on calls,
though callback methods like</span> <span class=
"c9">deliveryComplete</span><span>&nbsp;offer a preview of the
control of the non-blocking API.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>We now have our complete code:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">import
org.eclipse.paho.client.mqttv3.*;</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">public class PahoMqttSubscribe
implements MqttCallback</span></p>
<p class="c3"><span class="c0">{</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">&nbsp; MqttClient client;</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">&nbsp; public PahoMqttSubscribe()
{}</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">&nbsp; public void
messageArrived(String topic, MqttMessage message)</span></p>
<p class="c4 c16"><span class="c0">throws Exception</span></p>
<p class="c3"><span class="c0">&nbsp; {</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; System.out.println
(topic + " " + new String (message.getPayload()));</span></p>
<p class="c3"><span class="c0">&nbsp; }</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">&nbsp; public void connectionLost
(Throwable cause) {}</span></p>
<p class="c3"><span class="c0">&nbsp; public void
deliveryComplete(IMqttDeliveryToken token) {}</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">&nbsp; public static void main
(String[] args) {</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; new
PahoMqttSubscribe().doDemo();</span></p>
<p class="c3"><span class="c0">&nbsp; }</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">&nbsp; public void doDemo()
{</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; try {</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp; client = new
MqttClient("tcp://m2m.eclipse.org:1883",</span></p>
<p class="c16 c4"><span class=
"c0">MqttClient.generateClientId());</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp;
client.connect();</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp;
client.setCallback(this);</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp;
client.subscribe("bbbexample/tmp36/c");</span></p>
<p class="c3 c6"></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp; // We&rsquo;ll
now idle here sleeping, but your app can be busy</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp; // working here
instead</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp;</span>
<span class="c0">while (true) {</span></p>
<p class="c3"><span class=
"c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
Thread.sleep (1000); } catch (InterruptedException e) {}</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp; }</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; }</span></p>
<p class="c3"><span class="c0">&nbsp; &nbsp; catch (MqttException
e) { e.printStackTrace (); }</span></p>
<p class="c3"><span class="c0">&nbsp; }</span></p>
<p class="c3"><span class="c0">}</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>All we have to do is compile and run it and for
that we&rsquo;ll need a JDK. It used to be the case that you had to
download a JDK for the Raspberry Pi&rsquo;s Linux, but</span>
<span>now t</span><span>he Pi&rsquo;s Raspbian distribution</span>
<span>comes with Oracle&rsquo;s JDK as standard, so to keep it
simple (and up to date) it is best to go to the RaspberryPi.org
downloads page to get and install the latest version of Raspbian.
For the Java version of the Paho MQTT libraries, we could use Maven
to install it, but as we are working with minimal tooling, we can
simply retrieve the jar file from the Eclipse Paho release
repository with this command:</span></p>
<p class="c6 c4"></p>
<p class="c4"><span class="c0">curl -O</span> <span class=
"c0">https://repo.eclipse.org/content/repositories/paho-releases/org/eclipse/paho/mqtt-client/0.4.0/mqtt-client-0.4.0.jar</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>With the library downloaded and in the same
directory, we can compile and run our application like
so:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">javac -cp mqtt-client-0.4.0.jar
PahoMqttSubscribe.java</span></p>
<p class="c3"><span class="c0">java -cp mqtt-client-0.4.0.jar:.
PahoMqttSubscribe</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>If the BeagleBone sensor is still running, the
program should start printing the temperature data as it is
received.</span></p>
<p class="c6 c4"></p>
<h2 class="c4"><a name="h.x8depvbslic8" id=
"h.x8depvbslic8"></a><span>Pi Lumination</span></h2>
<p class="c6 c4"></p>
<p class="c4"><span>It&rsquo;s at this point we take a brief
digression into how to make these results turn up in the form of
LEDs being illuminated. It is, of course, perfectly reasonable to
take the GPIO pins on the Raspberry Pi and wire them, with
breadboard and jumper cables, to LEDs. But, we are more interested
in getting some quick illumination so have opted for the BerryClip
(</span><span class="c10"><a class="c1" href=
"http://www.raspberrypi-spy.co.uk/berryclip-6-led-add-on-board/">http://www.raspberrypi-spy.co.uk/berryclip-6-led-add-on-board/</a></span><span>),
a small add-on board kit with gives us 6 LEDs, a button and a
buzzer in one kit.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>Controlling the BerryClip&rsquo;s LEDs from
Java can be accomplished by use of the Pi4J library
(</span><span class="c10"><a class="c1" href=
"http://pi4j.com/">http://pi4j.com/</a></span><span>). This is a
Java wrapper around the WiringPi library and gives extensive access
to the Pi&rsquo;s GPIO controller and pins. There is one caveat,
programs using Pi4J have to be run as root. Pi4J is packaged as a
.deb file and can be installed with the commands:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">wget
http://pi4j.googlecode.com/files/pi4j-0.0.5.deb</span></p>
<p class="c3"><span class="c0">sudo dpkg -i
pi4j-0.0.5.deb</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>With the library installed we can modify the
code so that when it is invoked it configures the LEDs, by
adding:</span></p>
<p class="c6 c4"></p>
<p class="c4"><span class="c0">&nbsp; final GpioController
gpio=GpioFactory.getInstance();</span></p>
<p class="c4"><span class="c0">&nbsp; GpioPinDigitalOutput pina =
gpio.provisionDigitalOutputPin(RaspiPin.GPIO_07,"PinA");</span></p>
<p class="c4"><span class="c0">&nbsp; GpioPinDigitalOutput pinb =
gpio.provisionDigitalOutputPin(RaspiPin.GPIO_00,"PinB");</span></p>
<p class="c4"><span class="c0">&nbsp; GpioPinDigitalOutput pinc =
gpio.provisionDigitalOutputPin(RaspiPin.GPIO_03,"PinC");</span></p>
<p class="c4"><span class="c0">&nbsp; GpioPinDigitalOutput pind =
gpio.provisionDigitalOutputPin(RaspiPin.GPIO_12,"PinD");</span></p>
<p class="c4"><span class="c0">&nbsp; GpioPinDigitalOutput pine =
gpio.provisionDigitalOutputPin(RaspiPin.GPIO_13,"PinE");</span></p>
<p class="c4"><span class="c0">&nbsp; GpioPinDigitalOutput pinf =
gpio.provisionDigitalOutputPin(RaspiPin.GPIO_14,"PinF");</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>And replacing the code in the messageArrived
method so that it sets the LEDs depending on the temperature, in
this case, over the range 20-30 degrees C:</span></p>
<p class="c6 c4"></p>
<p class="c4"><span class="c0">&nbsp; public void
messageArrived(String topic, MqttMessage message) throws
Exception</span></p>
<p class="c4"><span class="c0">&nbsp; {</span></p>
<p class="c4"><span class="c0">&nbsp; &nbsp; String msg=new
String(message.getPayload());</span></p>
<p class="c4"><span class="c0">&nbsp; &nbsp; Double
dval=Double.parseDouble(msg);</span></p>
<p class="c4"><span class="c0">&nbsp; &nbsp; int
val=dval.intValue();</span></p>
<p class="c4"><span class="c0">&nbsp; &nbsp;
pinf.setState(val&gt;=20);</span></p>
<p class="c4"><span class="c0">&nbsp; &nbsp;
pine.setState(val&gt;=22);</span></p>
<p class="c4"><span class="c0">&nbsp; &nbsp;
pind.setState(val&gt;=24);</span></p>
<p class="c4"><span class="c0">&nbsp; &nbsp;
pinc.setState(val&gt;=26);</span></p>
<p class="c4"><span class="c0">&nbsp; &nbsp;
pinb.setState(val&gt;=28);</span></p>
<p class="c4"><span class="c0">&nbsp; &nbsp;
pina.setState(val&gt;=30);</span></p>
<p class="c4"><span class="c0">&nbsp; }</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>To compile and run the code now will require
the Pi4J libraries to be included on the classpath like
so:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">javac -cp
mqtt-client-0.4.0.jar:/opt/pi4j/lib/'*'
PahoMqttSubLED.java</span></p>
<p class="c3"><span class="c0">sudo java -cp
mqtt-client-0.4.0.jar:/opt/pi4j/lib/'*':. PahoMqttSubLED</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>Now, the temperature sensor on the BeagleBone
Black will be reflected in the LEDs. If you want to test that, try
touching the temperature sensor on the BeagleBone.</span></p>
<p class="c6 c4"></p>
<h2 class="c4"><a name="h.idk0l737lonn" id=
"h.idk0l737lonn"></a><span>Going deeper with MQTT</span></h2>
<p class="c6 c4"></p>
<p class="c4"><span>So far, we&rsquo;ve used MQTT at its very basic
level. Despite this, we have already built a system that can handle
multiple displays without modification as each display client just
subscribes to the temperature updates. And by changing the topic
for each sensor, we can publish data from any number of sensors and
come up with more complex, rich displays.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>But there are some things you may notice with
our basic setup. We&rsquo;ll look at some of them now and how MQTT
already has solutions for them.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span class="c11">More topics</span><span>: Our
Raspberry Pi display only subscribes to a single topic for its
data. When publishing, you have to use &ldquo;absolute&rdquo;
topics, but when subscribing it is possible to use wildcard
characters to define a range of topics we want the code to listen
to. The wildcard characters for MQTT topics are &ldquo;#&rdquo; and
&ldquo;+&rdquo;. A &ldquo;#&rdquo; in the topic means, in the
implied topic hierarchy, all topics at this level and their
children, while a &ldquo;+&rdquo; limits it to the single immediate
level. So, if we wanted to subscribe to all the messages from the
temperature sensor, we could change</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">&nbsp;
client.subscribe("bbbexample/tmp36/c");</span></p>
<p class="c6 c4"></p>
<p class="c4"><span>to</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">&nbsp;
client.subscribe("bbbexample/tmp36/+");</span></p>
<p class="c3 c6"></p>
<p class="c4"><span>Which would mean that messages for both
&ldquo;bbbexample/tmp36/mv&rdquo; and
&ldquo;bbbexample/tmp36/c&rdquo; would arrive at the</span>
<span class="c9">messageArrived</span><span>&nbsp;method. It would
be up to the code to distinguish between the topics and decide what
action it wants to take. Other examples of topic subscriptions
would be &ldquo;bbbexample/#&rdquo;, which would match any message
sent to a subtopic of &ldquo;bbbexample&rdquo; and
&ldquo;bbbexample/+/c&rdquo; which would match messages to any
immediate child of &ldquo;bbbexample&rdquo; which had an immediate
child &ldquo;c&rdquo;. &nbsp;</span></p>
<p class="c6 c4"></p>
<p class="c4"><span class="c11">Retention</span><span>: If you have
built this project and started the display client before starting
the BeagleBone&rsquo;s Python code, you will notice that nothing
happens at the display client until the Python code is started and
starts emitting messages. This is fine for many applications, but
where clients may be connecting at any point they may require the
last message&rsquo;s values so they can process them. MQTT brokers
are cable of retaining messages for late arriving clients; all a
client has to do is ask when posting the message. Changing the
sensor client&rsquo;s publish lines to do so simply means setting a
parameter</span> <span class="c9">retain</span><span>&nbsp;to be
true:</span></p>
<p class="c6 c4"></p>
<p class="c3"><span class="c0">&nbsp;
mqttc.publish("bbbexample/tmp36/mv","%.2f" % millivolts,
retain=1);</span></p>
<p class="c3"><span class="c0">&nbsp;
mqttc.publish("bbbexample/tmp36/c","%.2f" % temp_c,
retain=1);</span></p>
<p class="c6 c4"></p>
<p class="c4"><span class="c11">Getting the message
through</span><span>: Because there are different levels of
assurance needed for different kinds of messages, MQTT supports
three levels of quality of service. These QoS settings can be set
when publishing a message or when subscribing to a topic. The
lowest and quickest level, 0, is the &ldquo;fire and forget&rdquo;
mode where messages are sent and no attempt is made to acknowledge
their reception. QoS 1 is the usual default setting where messages
are sent, and re-sent, until there&rsquo;s at least one
acknowledgement. It&rsquo;s slower than &ldquo;fire and
forget&rdquo; but gives some assurance the message has got through,
though the downside is that multiple copies of the message may be
received. QoS 2 is the slowest of the settings as it goes through a
complete two-stage process of acknowledgement, which ensures that
one, and only one, copy of a message is delivered.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span class="c11">Losing the connection</span><span>:
When a client goes &ldquo;off air&rdquo; abnormally, it is normally
hard for other clients to detect that anomaly. With MQTT, this is
easier thanks to what are called wills. A will is a topic and a
message payload that a client can lodge with the broker with the
implicit instruction &ldquo;in the event that you can&rsquo;t get
in touch with me and I haven&rsquo;t cleanly disconnected, deliver
this message for me&rdquo;. The various Paho MQTT APIs have
different ways of setting this; in Python, a</span> <span class=
"c9">setWill</span><span>&nbsp;method on the MQTT connection is
used, while in the Java API, the will is part of a collection of
options the developer can set in</span> <span class=
"c9">MqttConnectionOptions</span><span>, an instance of which can
be passed to the connect method.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span class="c11">Recovering the
connection</span><span>: With those quality of service settings,
the client has to be able to pick up the pieces when it&rsquo;s
been disconnected and is reconnecting.</span> <span>There&rsquo;s a
pair of elements to this in MQTT. &nbsp;Firstly there is a clean
flag that is usually set by default. This tells the client and
server to start afresh every time they connect. If the clean flag
is set to false, it is then the second element comes into play.
This is the client ID, which we mentioned previously while setting
to a different value each time, can also be set to a fixed (or
deterministically generated)</span> <span>string. This changes how
the broker and client connect.</span>
<span>When</span><span>&nbsp;a client with the same client ID as
its previous connection connects to the server and the clean flag
is false, the broker and client will work to ensure the new session
starts from where the old one left off.</span><sup><a href="#cmnt2"
name="cmnt_ref2" id=
"cmnt_ref2">[b]</a></sup><span>&nbsp;</span><span>To help in this,
client libraries implement various forms of persistence for their
connections so they can figure out what they were in the process of
sending. Depending on the use case, this means that you can create
anything from a &ldquo;fire and forget&rdquo; stateless
stats-gathering network to a network-resilient,</span>
<span>assured-delivery</span><span>&nbsp;platform with
MQTT.</span></p>
<p class="c6 c4"></p>
<p class="c4"><span class="c11">Securing the
connection</span><span>: For simplicity, we&rsquo;ve been using
un-authenticated and un-encrypted connections to the MQTT broker so
anyone could have found out what the temperature was. MQTT does,
though, support both authentication and SSL-encrypted connections
for when the data is more mission critical than the temperature of
your office (or fingers).</span></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<h2 class="c4"><a name="h.zgc7227jidjd" id=
"h.zgc7227jidjd"></a><span>Further experiments</span></h2>
<p class="c4"><span>In the GitHub repository, there&rsquo;s an
extended example of the code which sends a test message from the
Raspberry Pi when the BerryClip&rsquo;s button is pressed and a
version of the Python code for the BeagleBone which picks up that
test message.</span><sup><a href="#cmnt3" name="cmnt_ref3" id=
"cmnt_ref3">[c]</a></sup></p>
<p class="c6 c4"></p>
<p class="c4"><span>If you want to attach a temperature sensor to
your Raspberry Pi, then you can use the TMP36 sensor, but
you&rsquo;ll also need an analog to digital converter like the
MCP3008 as the Pi doesn&rsquo;t have any analog pins. Instructions
on the hardware can be found in another project from the AdaFruit
Learning System (</span><span class="c10"><a class="c1" href=
"http://learn.adafruit.com/send-raspberry-pi-data-to-cosm/connecting-the-cobbler-slash-mcp3008-slash-tmp36">http://learn.adafruit.com/send-raspberry-pi-data-to-cosm/connecting-the-cobbler-slash-mcp3008-slash-tmp36</a></span><span>).
The other option is to use a digital thermometer like the DS18B20 -
instructions for interfacing that are on the Raspberry Spy blog
(</span><span class="c10"><a class="c1" href=
"http://www.raspberrypi-spy.co.uk/2013/03/raspberry-pi-1-wire-digital-thermometer-sensor/">http://www.raspberrypi-spy.co.uk/2013/03/raspberry-pi-1-wire-digital-thermometer-sensor/</a></span><span>).</span></p>
<p class="c6 c4"></p>
<h2 class="c4 c14"><a name="h.ls1ah07w8505" id=
"h.ls1ah07w8505"></a><span>Wrapping up the software</span></h2>
<p class="c4"><span>We&rsquo;ve only touched on the capabilities of
MQTT and the capabilities of the libraries from the Eclipse Paho
project, which also has, at various stages of development or
release, libraries for C, C++, JavaScript and Lua along with
Eclipse IDE tools to make it easier to work with MQTT across
different platforms. As you can see, MQTT is ideal for the Internet
of Things with its combination of lightweight code and extensive
functionality&hellip; it&rsquo;s easy to use, built for the modern
mostly-reliable internet and light on the hardware and power needs,
making it a leading candidate for the network glue in your next M2M
project.</span></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c4"><span>&nbsp;</span></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
<p class="c6 c4"></p>
</body>
</html>
