<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Paho C++: mqtt::thread_queue&lt; T, Container &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pahologo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Paho C++
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">The Paho MQTT C++ Client Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmqtt_1_1thread__queue.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classmqtt_1_1thread__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mqtt::thread_queue&lt; T, Container &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A thread-safe queue for inter-thread communication.  
 <a href="classmqtt_1_1thread__queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="thread__queue_8h_source.html">thread_queue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3541d204c67e24f64b70f26d721bc032"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a3541d204c67e24f64b70f26d721bc032">container_type</a> = Container</td></tr>
<tr class="memdesc:a3541d204c67e24f64b70f26d721bc032"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying container type to use for the queue.  <a href="#a3541d204c67e24f64b70f26d721bc032">More...</a><br/></td></tr>
<tr class="separator:a3541d204c67e24f64b70f26d721bc032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ec540c315e1284e9df8fe1db9e0837"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> = T</td></tr>
<tr class="memdesc:a03ec540c315e1284e9df8fe1db9e0837"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of items to be held in the queue.  <a href="#a03ec540c315e1284e9df8fe1db9e0837">More...</a><br/></td></tr>
<tr class="separator:a03ec540c315e1284e9df8fe1db9e0837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0258577b49c271d5b330ed81f2d596d6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> = typename Container::size_type</td></tr>
<tr class="memdesc:a0258577b49c271d5b330ed81f2d596d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to specify number of items in the container.  <a href="#a0258577b49c271d5b330ed81f2d596d6">More...</a><br/></td></tr>
<tr class="separator:a0258577b49c271d5b330ed81f2d596d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69e67e267fb59e0c2902e476a3456e1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69e67e267fb59e0c2902e476a3456e1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a69e67e267fb59e0c2902e476a3456e1f">thread_queue</a> ()</td></tr>
<tr class="memdesc:a69e67e267fb59e0c2902e476a3456e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a queue with the maximum capacity. <br/></td></tr>
<tr class="separator:a69e67e267fb59e0c2902e476a3456e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae134cc86ccf92a9b1a7843fec5ffc189"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#ae134cc86ccf92a9b1a7843fec5ffc189">thread_queue</a> (size_t cap)</td></tr>
<tr class="memdesc:ae134cc86ccf92a9b1a7843fec5ffc189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a queue with the specified capacity.  <a href="#ae134cc86ccf92a9b1a7843fec5ffc189">More...</a><br/></td></tr>
<tr class="separator:ae134cc86ccf92a9b1a7843fec5ffc189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26821f9803dd991601ceac9d6043cef9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a26821f9803dd991601ceac9d6043cef9">empty</a> () const </td></tr>
<tr class="memdesc:a26821f9803dd991601ceac9d6043cef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the queue is empty.  <a href="#a26821f9803dd991601ceac9d6043cef9">More...</a><br/></td></tr>
<tr class="separator:a26821f9803dd991601ceac9d6043cef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c51ca4923aac7765dbf5639afb5dd5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a4c51ca4923aac7765dbf5639afb5dd5a">capacity</a> () const </td></tr>
<tr class="memdesc:a4c51ca4923aac7765dbf5639afb5dd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the capacity of the queue.  <a href="#a4c51ca4923aac7765dbf5639afb5dd5a">More...</a><br/></td></tr>
<tr class="separator:a4c51ca4923aac7765dbf5639afb5dd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3d5689a5c9de91df58f08751a9a151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a1a3d5689a5c9de91df58f08751a9a151">capacity</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> cap)</td></tr>
<tr class="memdesc:a1a3d5689a5c9de91df58f08751a9a151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the capacity of the queue.  <a href="#a1a3d5689a5c9de91df58f08751a9a151">More...</a><br/></td></tr>
<tr class="separator:a1a3d5689a5c9de91df58f08751a9a151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f23c815b33be58b2ac2a6aba159108d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a6f23c815b33be58b2ac2a6aba159108d">size</a> () const </td></tr>
<tr class="memdesc:a6f23c815b33be58b2ac2a6aba159108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of items in the queue.  <a href="#a6f23c815b33be58b2ac2a6aba159108d">More...</a><br/></td></tr>
<tr class="separator:a6f23c815b33be58b2ac2a6aba159108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af480a8f58a85ac1456232dcbe88b43a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#af480a8f58a85ac1456232dcbe88b43a0">put</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> val)</td></tr>
<tr class="memdesc:af480a8f58a85ac1456232dcbe88b43a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the queue.  <a href="#af480a8f58a85ac1456232dcbe88b43a0">More...</a><br/></td></tr>
<tr class="separator:af480a8f58a85ac1456232dcbe88b43a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422932e446605d6df9cad670a3d5f795"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a422932e446605d6df9cad670a3d5f795">try_put</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> val)</td></tr>
<tr class="memdesc:a422932e446605d6df9cad670a3d5f795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking attempt to place an item into the queue.  <a href="#a422932e446605d6df9cad670a3d5f795">More...</a><br/></td></tr>
<tr class="separator:a422932e446605d6df9cad670a3d5f795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c10d47c27bd0acfd61dd9172f807de"><td class="memTemplParams" colspan="2">template&lt;typename Rep , class Period &gt; </td></tr>
<tr class="memitem:ab0c10d47c27bd0acfd61dd9172f807de"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#ab0c10d47c27bd0acfd61dd9172f807de">try_put_for</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *val, const std::chrono::duration&lt; Rep, Period &gt; &amp;relTime)</td></tr>
<tr class="memdesc:ab0c10d47c27bd0acfd61dd9172f807de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to place an item in the queue with a bounded wait.  <a href="#ab0c10d47c27bd0acfd61dd9172f807de">More...</a><br/></td></tr>
<tr class="separator:ab0c10d47c27bd0acfd61dd9172f807de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7086ef1aff63b6f6bc905a4653f33b5"><td class="memTemplParams" colspan="2">template&lt;class Clock , class Duration &gt; </td></tr>
<tr class="memitem:ab7086ef1aff63b6f6bc905a4653f33b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#ab7086ef1aff63b6f6bc905a4653f33b5">try_put_until</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *val, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;absTime)</td></tr>
<tr class="memdesc:ab7086ef1aff63b6f6bc905a4653f33b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to place an item in the queue with a bounded wait to an absolute time point.  <a href="#ab7086ef1aff63b6f6bc905a4653f33b5">More...</a><br/></td></tr>
<tr class="separator:ab7086ef1aff63b6f6bc905a4653f33b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10061c6d4eeefa9d6e3002fc2eea6c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#ab10061c6d4eeefa9d6e3002fc2eea6c3">get</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *val)</td></tr>
<tr class="memdesc:ab10061c6d4eeefa9d6e3002fc2eea6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a value from the queue.  <a href="#ab10061c6d4eeefa9d6e3002fc2eea6c3">More...</a><br/></td></tr>
<tr class="separator:ab10061c6d4eeefa9d6e3002fc2eea6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86a422283cfc8c6b95098dcbc495533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#af86a422283cfc8c6b95098dcbc495533">get</a> ()</td></tr>
<tr class="memdesc:af86a422283cfc8c6b95098dcbc495533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a value from the queue.  <a href="#af86a422283cfc8c6b95098dcbc495533">More...</a><br/></td></tr>
<tr class="separator:af86a422283cfc8c6b95098dcbc495533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696a704cfcf4333390ee632bc4e069c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a696a704cfcf4333390ee632bc4e069c9">try_get</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *val)</td></tr>
<tr class="memdesc:a696a704cfcf4333390ee632bc4e069c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to remove a value from the queue without blocking.  <a href="#a696a704cfcf4333390ee632bc4e069c9">More...</a><br/></td></tr>
<tr class="separator:a696a704cfcf4333390ee632bc4e069c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f762168e9543c7f3988c5a41d4c921b"><td class="memTemplParams" colspan="2">template&lt;typename Rep , class Period &gt; </td></tr>
<tr class="memitem:a4f762168e9543c7f3988c5a41d4c921b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a4f762168e9543c7f3988c5a41d4c921b">try_get_for</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *val, const std::chrono::duration&lt; Rep, Period &gt; &amp;relTime)</td></tr>
<tr class="memdesc:a4f762168e9543c7f3988c5a41d4c921b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to remove an item from the queue for a bounded amout of time.  <a href="#a4f762168e9543c7f3988c5a41d4c921b">More...</a><br/></td></tr>
<tr class="separator:a4f762168e9543c7f3988c5a41d4c921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d9ff987f6b59b070c7da4e3867cacb"><td class="memTemplParams" colspan="2">template&lt;class Clock , class Duration &gt; </td></tr>
<tr class="memitem:af8d9ff987f6b59b070c7da4e3867cacb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#af8d9ff987f6b59b070c7da4e3867cacb">try_get_until</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *val, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;absTime)</td></tr>
<tr class="memdesc:af8d9ff987f6b59b070c7da4e3867cacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to remove an item from the queue for a bounded amout of time.  <a href="#af8d9ff987f6b59b070c7da4e3867cacb">More...</a><br/></td></tr>
<tr class="separator:af8d9ff987f6b59b070c7da4e3867cacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5c0a3b1044293fddcd6d100c39069a26"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a5c0a3b1044293fddcd6d100c39069a26">MAX_CAPACITY</a> = std::numeric_limits&lt;<a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&gt;::max()</td></tr>
<tr class="memdesc:a5c0a3b1044293fddcd6d100c39069a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum capacity of the queue.  <a href="#a5c0a3b1044293fddcd6d100c39069a26">More...</a><br/></td></tr>
<tr class="separator:a5c0a3b1044293fddcd6d100c39069a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, class Container = std::deque&lt;T&gt;&gt;<br/>
class mqtt::thread_queue&lt; T, Container &gt;</h3>

<p>A thread-safe queue for inter-thread communication. </p>
<p>This is a lockinq queue with blocking operations. The <a class="el" href="classmqtt_1_1thread__queue.html#af86a422283cfc8c6b95098dcbc495533" title="Retrieve a value from the queue. ">get()</a> operations can always block on an empty queue, but have variations for non-blocking (try_get) and bounded-time blocking (try_get_for, try_get_until). </p>
<dl class="section user"><dt></dt><dd>The default queue has a capacity that is unbounded in the practical sense, limited by available memory. In this mode the object will not block when placing values into the queue. A capacity can bet set with the construtor or, at any time later by calling the <a class="el" href="classmqtt_1_1thread__queue.html#a1a3d5689a5c9de91df58f08751a9a151">capacity(size_type)</a> method. Using this latter method, the capacity can be set to an amount smaller than the current size of the queue. In that case all put's to the queue will block until the number of items are removed from the queue to bring the size below the new capacity. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that the queue uses move semantics to place items into the queue and remove items from the queue. This means that the type, T, of the data held by the queue only needs to follow move semantics; not copy semantics. In addition, this means that copies of the value will <em>not</em> be left in the queue. This is especially useful when creating queues of shared pointers, as the "dead" part of the queue will not hold onto a reference count after the item has been removed from the queue.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of the items to be held in the queue. </td></tr>
    <tr><td class="paramname">Container</td><td>The type of the underlying container to use. It must support back(), front(), push_back(), pop_front(). </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a3541d204c67e24f64b70f26d721bc032"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::<a class="el" href="classmqtt_1_1thread__queue.html#a3541d204c67e24f64b70f26d721bc032">container_type</a> =  Container</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The underlying container type to use for the queue. </p>

</div>
</div>
<a class="anchor" id="a0258577b49c271d5b330ed81f2d596d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::<a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> =  typename Container::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used to specify number of items in the container. </p>

</div>
</div>
<a class="anchor" id="a03ec540c315e1284e9df8fe1db9e0837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of items to be held in the queue. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae134cc86ccf92a9b1a7843fec5ffc189"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::<a class="el" href="classmqtt_1_1thread__queue.html">thread_queue</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a queue with the specified capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>The maximum number of items that can be placed in the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4c51ca4923aac7765dbf5639afb5dd5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the capacity of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of elements before the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a3d5689a5c9de91df58f08751a9a151"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the capacity of the queue. </p>
<p>Note that the capacity can be set to a value smaller than the current size of the queue. In that event, all calls to <a class="el" href="classmqtt_1_1thread__queue.html#af480a8f58a85ac1456232dcbe88b43a0" title="Put an item into the queue. ">put()</a> will block until a suffucuent number </p>

</div>
</div>
<a class="anchor" id="a26821f9803dd991601ceac9d6043cef9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the queue is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if there are no elements in the queue, <em>false</em> if there are any items in the queue. </dd></dl>

</div>
</div>
<a class="anchor" id="ab10061c6d4eeefa9d6e3002fc2eea6c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a value from the queue. </p>
<p>If the queue is empty, this will block indefinitely until a value is added to the queue by another thread, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Pointer to a variable to receive the value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af86a422283cfc8c6b95098dcbc495533"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a value from the queue. </p>
<p>If the queue is empty, this will block indefinitely until a value is added to the queue by another thread, </p>
<dl class="section return"><dt>Returns</dt><dd>The value removed from the queue </dd></dl>

</div>
</div>
<a class="anchor" id="af480a8f58a85ac1456232dcbe88b43a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an item into the queue. </p>
<p>If the queue is full, this will block the caller until items are removed bringing the size less than the capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to add to the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f23c815b33be58b2ac2a6aba159108d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of items in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of items in the queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a696a704cfcf4333390ee632bc4e069c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to remove a value from the queue without blocking. </p>
<p>If the queue is currently empty, this will return immediately with a failure, otherwise it will get the next value and return it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Pointer to a variable to receive the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if a value was removed from the queue, <em>false</em> if the queue is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f762168e9543c7f3988c5a41d4c921b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_get_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>relTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to remove an item from the queue for a bounded amout of time. </p>
<p>This will retrieve the next item from the queue. If the queue is empty, it will wait the specified amout of time for an item to arive before timing out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Pointer to a variable to receive the value. </td></tr>
    <tr><td class="paramname">relTime</td><td>The amount of time to wait until timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value was removed the queue, <em>false</em> if a timeout occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="af8d9ff987f6b59b070c7da4e3867cacb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_get_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>absTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to remove an item from the queue for a bounded amout of time. </p>
<p>This will retrieve the next item from the queue. If the queue is empty, it will wait until the specified time for an item to arive before timing out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Pointer to a variable to receive the value. </td></tr>
    <tr><td class="paramname">absTime</td><td>The absolute time to wait to before timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value was removed from the queue, <em>false</em> if a timeout occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a422932e446605d6df9cad670a3d5f795"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-blocking attempt to place an item into the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to add to the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the item was added to the queue, <em>false</em> if the item was not added because the queue is currently full. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0c10d47c27bd0acfd61dd9172f807de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_put_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>relTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to place an item in the queue with a bounded wait. </p>
<p>This will attempt to place the value in the queue, but if it is full, it will wait up to the specified time duration before timing out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to add to the queue. </td></tr>
    <tr><td class="paramname">relTime</td><td>The amount of time to wait until timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value was added to the queue, <em>false</em> if a timeout occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7086ef1aff63b6f6bc905a4653f33b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_put_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>absTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to place an item in the queue with a bounded wait to an absolute time point. </p>
<p>This will attempt to place the value in the queue, but if it is full, it will wait up until the specified time before timing out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to add to the queue. </td></tr>
    <tr><td class="paramname">absTime</td><td>The absolute time to wait to before timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value was added to the queue, <em>false</em> if a timeout occurred. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5c0a3b1044293fddcd6d100c39069a26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::MAX_CAPACITY = std::numeric_limits&lt;<a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum capacity of the queue. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/mqtt/<a class="el" href="thread__queue_8h_source.html">thread_queue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>mqtt</b></li><li class="navelem"><a class="el" href="classmqtt_1_1thread__queue.html">thread_queue</a></li>
    <li class="footer">Generated on Sun Jul 23 2017 10:24:30 for Paho C++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
